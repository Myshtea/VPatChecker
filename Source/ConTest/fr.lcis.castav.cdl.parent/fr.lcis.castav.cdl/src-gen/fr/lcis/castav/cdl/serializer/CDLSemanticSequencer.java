/*
 * generated by Xtext 2.29.0
 */
package fr.lcis.castav.cdl.serializer;

import com.google.inject.Inject;
import fr.lcis.castav.cdl.cDL.BooleanType;
import fr.lcis.castav.cdl.cDL.CDLPackage;
import fr.lcis.castav.cdl.cDL.Context;
import fr.lcis.castav.cdl.cDL.ContextExpression;
import fr.lcis.castav.cdl.cDL.ContextMapping;
import fr.lcis.castav.cdl.cDL.ContextModel;
import fr.lcis.castav.cdl.cDL.ContextValue;
import fr.lcis.castav.cdl.cDL.DefinedType;
import fr.lcis.castav.cdl.cDL.DoubleType;
import fr.lcis.castav.cdl.cDL.IntegerType;
import fr.lcis.castav.cdl.cDL.Property;
import fr.lcis.castav.cdl.cDL.Provider;
import fr.lcis.castav.cdl.cDL.Providers;
import fr.lcis.castav.cdl.cDL.Situation;
import fr.lcis.castav.cdl.cDL.StringType;
import fr.lcis.castav.cdl.cDL.TypeRef;
import fr.lcis.castav.cdl.services.CDLGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class CDLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CDLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CDLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CDLPackage.BOOLEAN_TYPE:
				sequence_BooleanType(context, (BooleanType) semanticObject); 
				return; 
			case CDLPackage.CONTEXT:
				sequence_Context(context, (Context) semanticObject); 
				return; 
			case CDLPackage.CONTEXT_EXPRESSION:
				sequence_ContextExpression(context, (ContextExpression) semanticObject); 
				return; 
			case CDLPackage.CONTEXT_MAPPING:
				sequence_ContextMapping(context, (ContextMapping) semanticObject); 
				return; 
			case CDLPackage.CONTEXT_MODEL:
				sequence_ContextModel(context, (ContextModel) semanticObject); 
				return; 
			case CDLPackage.CONTEXT_VALUE:
				sequence_ContextValue(context, (ContextValue) semanticObject); 
				return; 
			case CDLPackage.DEFINED_TYPE:
				sequence_DefinedType(context, (DefinedType) semanticObject); 
				return; 
			case CDLPackage.DOUBLE_TYPE:
				sequence_DoubleType(context, (DoubleType) semanticObject); 
				return; 
			case CDLPackage.INTEGER_TYPE:
				sequence_IntegerType(context, (IntegerType) semanticObject); 
				return; 
			case CDLPackage.PROPERTY:
				sequence_Property(context, (Property) semanticObject); 
				return; 
			case CDLPackage.PROVIDER:
				sequence_Provider(context, (Provider) semanticObject); 
				return; 
			case CDLPackage.PROVIDERS:
				sequence_Providers(context, (Providers) semanticObject); 
				return; 
			case CDLPackage.SITUATION:
				sequence_Situation(context, (Situation) semanticObject); 
				return; 
			case CDLPackage.STRING_TYPE:
				sequence_StringType(context, (StringType) semanticObject); 
				return; 
			case CDLPackage.TYPE_REF:
				sequence_TypeRef(context, (TypeRef) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     SimpleType returns BooleanType
	 *     BooleanType returns BooleanType
	 *
	 * Constraint:
	 *     {BooleanType}
	 * </pre>
	 */
	protected void sequence_BooleanType(ISerializationContext context, BooleanType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ContextExpression returns ContextExpression
	 *
	 * Constraint:
	 *     (ref=[Property|FQN] value=ContextValue expr=ContextExpression?)
	 * </pre>
	 */
	protected void sequence_ContextExpression(ISerializationContext context, ContextExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ContextMapping returns ContextMapping
	 *
	 * Constraint:
	 *     (ref=[ContextValue|FQN] expression=ContextExpression)
	 * </pre>
	 */
	protected void sequence_ContextMapping(ISerializationContext context, ContextMapping semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CDLPackage.Literals.CONTEXT_MAPPING__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CDLPackage.Literals.CONTEXT_MAPPING__REF));
			if (transientValues.isValueTransient(semanticObject, CDLPackage.Literals.CONTEXT_MAPPING__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CDLPackage.Literals.CONTEXT_MAPPING__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getContextMappingAccess().getRefContextValueFQNParserRuleCall_0_0_1(), semanticObject.eGet(CDLPackage.Literals.CONTEXT_MAPPING__REF, false));
		feeder.accept(grammarAccess.getContextMappingAccess().getExpressionContextExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ContextModel returns ContextModel
	 *
	 * Constraint:
	 *     ((Providers+=Providers | Situations+=Situation | Types+=DefinedType)? (name=ID Contexts+=Context*)?)+
	 * </pre>
	 */
	protected void sequence_ContextModel(ISerializationContext context, ContextModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ContextValue returns ContextValue
	 *
	 * Constraint:
	 *     (name=STRING | name=ID)
	 * </pre>
	 */
	protected void sequence_ContextValue(ISerializationContext context, ContextValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Context returns Context
	 *
	 * Constraint:
	 *     (
	 *         static?='static'? 
	 *         name=ID 
	 *         (derived?='derives' derives+=[Context|ID] derives+=[Context|ID]*)? 
	 *         (providers+=[Provider|ID] providers+=[Provider|ID]*)? 
	 *         properties+=Property 
	 *         properties+=Property* 
	 *         (mappings+=ContextMapping mappings+=ContextMapping*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_Context(ISerializationContext context, Context semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DefinedType returns DefinedType
	 *
	 * Constraint:
	 *     (name=ID values+=ContextValue values+=ContextValue*)
	 * </pre>
	 */
	protected void sequence_DefinedType(ISerializationContext context, DefinedType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SimpleType returns DoubleType
	 *     DoubleType returns DoubleType
	 *
	 * Constraint:
	 *     {DoubleType}
	 * </pre>
	 */
	protected void sequence_DoubleType(ISerializationContext context, DoubleType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SimpleType returns IntegerType
	 *     IntegerType returns IntegerType
	 *
	 * Constraint:
	 *     {IntegerType}
	 * </pre>
	 */
	protected void sequence_IntegerType(ISerializationContext context, IntegerType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns Property
	 *
	 * Constraint:
	 *     (name=ID (type=TypeRef | type=SimpleType))
	 * </pre>
	 */
	protected void sequence_Property(ISerializationContext context, Property semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Provider returns Provider
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_Provider(ISerializationContext context, Provider semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CDLPackage.Literals.PROVIDER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CDLPackage.Literals.PROVIDER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProviderAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Providers returns Providers
	 *
	 * Constraint:
	 *     (providers+=Provider providers+=Provider*)
	 * </pre>
	 */
	protected void sequence_Providers(ISerializationContext context, Providers semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Situation returns Situation
	 *
	 * Constraint:
	 *     (name=ID expression+=ContextExpression)
	 * </pre>
	 */
	protected void sequence_Situation(ISerializationContext context, Situation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SimpleType returns StringType
	 *     StringType returns StringType
	 *
	 * Constraint:
	 *     {StringType}
	 * </pre>
	 */
	protected void sequence_StringType(ISerializationContext context, StringType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypeRef returns TypeRef
	 *
	 * Constraint:
	 *     ref=[DefinedType|ID]
	 * </pre>
	 */
	protected void sequence_TypeRef(ISerializationContext context, TypeRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CDLPackage.Literals.TYPE_REF__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CDLPackage.Literals.TYPE_REF__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeRefAccess().getRefDefinedTypeIDTerminalRuleCall_0_1(), semanticObject.eGet(CDLPackage.Literals.TYPE_REF__REF, false));
		feeder.finish();
	}
	
	
}
