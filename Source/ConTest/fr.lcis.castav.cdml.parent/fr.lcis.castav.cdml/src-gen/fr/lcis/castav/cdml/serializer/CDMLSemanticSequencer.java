/*
 * generated by Xtext 2.29.0
 */
package fr.lcis.castav.cdml.serializer;

import com.google.inject.Inject;
import fr.lcis.castav.cdml.cDML.Adaptation;
import fr.lcis.castav.cdml.cDML.AtomicState;
import fr.lcis.castav.cdml.cDML.CDMLPackage;
import fr.lcis.castav.cdml.cDML.Cdml;
import fr.lcis.castav.cdml.cDML.Context;
import fr.lcis.castav.cdml.cDML.Contexts;
import fr.lcis.castav.cdml.cDML.Event;
import fr.lcis.castav.cdml.cDML.Permission;
import fr.lcis.castav.cdml.cDML.PermissionValue;
import fr.lcis.castav.cdml.cDML.Sink;
import fr.lcis.castav.cdml.cDML.Situation;
import fr.lcis.castav.cdml.cDML.Situations;
import fr.lcis.castav.cdml.cDML.Source;
import fr.lcis.castav.cdml.cDML.Statemachine;
import fr.lcis.castav.cdml.cDML.StaticContext;
import fr.lcis.castav.cdml.cDML.StaticContexts;
import fr.lcis.castav.cdml.cDML.SuperState;
import fr.lcis.castav.cdml.cDML.Transition;
import fr.lcis.castav.cdml.services.CDMLGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class CDMLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CDMLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CDMLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CDMLPackage.ADAPTATION:
				sequence_Adaptation(context, (Adaptation) semanticObject); 
				return; 
			case CDMLPackage.ATOMIC_STATE:
				if (rule == grammarAccess.getAtomicStateRule()) {
					sequence_AtomicState(context, (AtomicState) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStateRule()) {
					sequence_AtomicState_State(context, (AtomicState) semanticObject); 
					return; 
				}
				else break;
			case CDMLPackage.CDML:
				sequence_Cdml(context, (Cdml) semanticObject); 
				return; 
			case CDMLPackage.CONTEXT:
				sequence_Context(context, (Context) semanticObject); 
				return; 
			case CDMLPackage.CONTEXTS:
				sequence_Contexts(context, (Contexts) semanticObject); 
				return; 
			case CDMLPackage.EVENT:
				sequence_Event(context, (Event) semanticObject); 
				return; 
			case CDMLPackage.PARAMETER:
				sequence_Parameter(context, (fr.lcis.castav.cdml.cDML.Parameter) semanticObject); 
				return; 
			case CDMLPackage.PERMISSION:
				sequence_Permission(context, (Permission) semanticObject); 
				return; 
			case CDMLPackage.PERMISSION_VALUE:
				sequence_PermissionValue(context, (PermissionValue) semanticObject); 
				return; 
			case CDMLPackage.SINK:
				sequence_Sink(context, (Sink) semanticObject); 
				return; 
			case CDMLPackage.SITUATION:
				sequence_Situation(context, (Situation) semanticObject); 
				return; 
			case CDMLPackage.SITUATIONS:
				sequence_Situations(context, (Situations) semanticObject); 
				return; 
			case CDMLPackage.SOURCE:
				sequence_Source(context, (Source) semanticObject); 
				return; 
			case CDMLPackage.STATEMACHINE:
				sequence_Statemachine(context, (Statemachine) semanticObject); 
				return; 
			case CDMLPackage.STATIC_CONTEXT:
				sequence_StaticContext(context, (StaticContext) semanticObject); 
				return; 
			case CDMLPackage.STATIC_CONTEXTS:
				sequence_StaticContexts(context, (StaticContexts) semanticObject); 
				return; 
			case CDMLPackage.SUPER_STATE:
				if (rule == grammarAccess.getStateRule()) {
					sequence_State_SuperState(context, (SuperState) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSuperStateRule()) {
					sequence_SuperState(context, (SuperState) semanticObject); 
					return; 
				}
				else break;
			case CDMLPackage.TRANSITION:
				sequence_Transition(context, (Transition) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Adaptation returns Adaptation
	 *
	 * Constraint:
	 *     (situations+=[Situation|ID] situations+=[Situation|ID]* state=[State|ID] states+=State*)
	 * </pre>
	 */
	protected void sequence_Adaptation(ISerializationContext context, Adaptation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AtomicState returns AtomicState
	 *
	 * Constraint:
	 *     (name=EString (contextAware?='awareof' contexts+=[Context|ID] contexts+=[Context|ID]*)?)
	 * </pre>
	 */
	protected void sequence_AtomicState(ISerializationContext context, AtomicState semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     State returns AtomicState
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         (contextAware?='awareof' contexts+=[Context|ID] contexts+=[Context|ID]*)? 
	 *         transitions+=Transition* 
	 *         (dataflows+=DataFlow dataflows+=DataFlow*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_AtomicState_State(ISerializationContext context, AtomicState semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Cdml returns Cdml
	 *
	 * Constraint:
	 *     (
	 *         (staticContexts+=StaticContexts | situations+=Situations | statemachines+=Statemachine | adaptations+=Adaptation)? 
	 *         (name=EString contexts+=Contexts?)?
	 *     )+
	 * </pre>
	 */
	protected void sequence_Cdml(ISerializationContext context, Cdml semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Context returns Context
	 *
	 * Constraint:
	 *     name=EString
	 * </pre>
	 */
	protected void sequence_Context(ISerializationContext context, Context semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CDMLPackage.Literals.CONTEXT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CDMLPackage.Literals.CONTEXT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getContextAccess().getNameEStringParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Contexts returns Contexts
	 *
	 * Constraint:
	 *     (contexts+=Context contexts+=Context*)
	 * </pre>
	 */
	protected void sequence_Contexts(ISerializationContext context, Contexts semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Event returns Event
	 *
	 * Constraint:
	 *     name=EString
	 * </pre>
	 */
	protected void sequence_Event(ISerializationContext context, Event semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CDMLPackage.Literals.EVENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CDMLPackage.Literals.EVENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEventAccess().getNameEStringParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (wildcard?='*' | value=ID | (source?='source' origin=[Source|FQN]))
	 * </pre>
	 */
	protected void sequence_Parameter(ISerializationContext context, fr.lcis.castav.cdml.cDML.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PermissionValue returns PermissionValue
	 *
	 * Constraint:
	 *     name=EString
	 * </pre>
	 */
	protected void sequence_PermissionValue(ISerializationContext context, PermissionValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CDMLPackage.Literals.PERMISSION_VALUE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CDMLPackage.Literals.PERMISSION_VALUE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPermissionValueAccess().getNameEStringParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Permission returns Permission
	 *
	 * Constraint:
	 *     (
	 *         (normal?='normal' permissionValues+=PermissionValue permissionValues+=PermissionValue*) | 
	 *         (dangerous?='dangerous' permissionValues+=PermissionValue permissionValues+=PermissionValue*) | 
	 *         signature?='signature' | 
	 *         signatureOrSystem?='signatureOrSystem'
	 *     )
	 * </pre>
	 */
	protected void sequence_Permission(ISerializationContext context, Permission semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataFlow returns Sink
	 *     Sink returns Sink
	 *
	 * Constraint:
	 *     (name=EString (parameters+=Parameter parameters+=Parameter*)?)
	 * </pre>
	 */
	protected void sequence_Sink(ISerializationContext context, Sink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Situation returns Situation
	 *
	 * Constraint:
	 *     (name=EString context=[Context|ID])
	 * </pre>
	 */
	protected void sequence_Situation(ISerializationContext context, Situation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CDMLPackage.Literals.SITUATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CDMLPackage.Literals.SITUATION__NAME));
			if (transientValues.isValueTransient(semanticObject, CDMLPackage.Literals.SITUATION__CONTEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CDMLPackage.Literals.SITUATION__CONTEXT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSituationAccess().getNameEStringParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSituationAccess().getContextContextIDTerminalRuleCall_2_0_1(), semanticObject.eGet(CDMLPackage.Literals.SITUATION__CONTEXT, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Situations returns Situations
	 *
	 * Constraint:
	 *     (situations+=Situation situations+=Situation*)
	 * </pre>
	 */
	protected void sequence_Situations(ISerializationContext context, Situations semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataFlow returns Source
	 *     Source returns Source
	 *
	 * Constraint:
	 *     (input?='input'? name=EString)
	 * </pre>
	 */
	protected void sequence_Source(ISerializationContext context, Source semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     State returns SuperState
	 *
	 * Constraint:
	 *     (name=EString abstracts=[Statemachine|ID] transitions+=Transition* (dataflows+=DataFlow dataflows+=DataFlow*)?)
	 * </pre>
	 */
	protected void sequence_State_SuperState(ISerializationContext context, SuperState semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statemachine returns Statemachine
	 *
	 * Constraint:
	 *     (name=EString (exported?='exported' permission=Permission?)? states+=State*)
	 * </pre>
	 */
	protected void sequence_Statemachine(ISerializationContext context, Statemachine semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StaticContext returns StaticContext
	 *
	 * Constraint:
	 *     (name=EString value=STRING)
	 * </pre>
	 */
	protected void sequence_StaticContext(ISerializationContext context, StaticContext semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CDMLPackage.Literals.STATIC_CONTEXT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CDMLPackage.Literals.STATIC_CONTEXT__NAME));
			if (transientValues.isValueTransient(semanticObject, CDMLPackage.Literals.STATIC_CONTEXT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CDMLPackage.Literals.STATIC_CONTEXT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStaticContextAccess().getNameEStringParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getStaticContextAccess().getValueSTRINGTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StaticContexts returns StaticContexts
	 *
	 * Constraint:
	 *     (staticContexts+=StaticContext staticContexts+=StaticContext*)
	 * </pre>
	 */
	protected void sequence_StaticContexts(ISerializationContext context, StaticContexts semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SuperState returns SuperState
	 *
	 * Constraint:
	 *     (name=EString abstracts=[Statemachine|ID])
	 * </pre>
	 */
	protected void sequence_SuperState(ISerializationContext context, SuperState semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CDMLPackage.Literals.STATE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CDMLPackage.Literals.STATE__NAME));
			if (transientValues.isValueTransient(semanticObject, CDMLPackage.Literals.SUPER_STATE__ABSTRACTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CDMLPackage.Literals.SUPER_STATE__ABSTRACTS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSuperStateAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSuperStateAccess().getAbstractsStatemachineIDTerminalRuleCall_4_0_1(), semanticObject.eGet(CDMLPackage.Literals.SUPER_STATE__ABSTRACTS, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Transition returns Transition
	 *
	 * Constraint:
	 *     (on=Event? ((external?='external' target=[State|FQN]) | target=[State|ID])?)
	 * </pre>
	 */
	protected void sequence_Transition(ISerializationContext context, Transition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
